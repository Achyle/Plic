package analyse;

import lexique.*;
import expression.*;
import variables.* ;

action code {: Lexique lexique = new Lexique();
			   Variables variables = Variables.getInstance();
			   int i = 0;
			   int deplacement = 0; 
			   int j = 0; :}; 

parser code {:

    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", column "+(s.right+1));
            }
        }

        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

terminal String CSTE_ENT, PARENTHESE_OUVERT, PARENTHESE_FERMER, PLUS, MOINS, FOIS, INF, SUP, TEST_EGAL, TEST_NON_EGAL,
				CLASS, IDF, FIN, VIRGULE, POINT_VIRGULE, STATUT, TYPE, EGALE, LIR, ECRIR, CSTE_CHAINE;

non terminal Lexique SYSTEME;
non terminal String	CLASSE, DECLARATION, LDECLARATION, DECL_CHAMP, LIDF, DECL_CONST, INSTRUCTION, AFFECT, LIRE, ECRIRE;
non terminal Expression EXP;

precedence left PARENTHESE_OUVERT, PARENTHESE_FERMER;
precedence left PLUS, MOINS;
precedence left FOIS;
precedence left INF, SUP, TEST_EGAL, TEST_NON_EGAL;

SYSTEME ::= CLASSE
  			{: RESULT = lexique; :} 
  		| ;

CLASSE ::= CLASS:classe IDF:nomClasse LDECLARATION FIN ;  		
   		
LDECLARATION ::= LDECLARATION DECLARATION
			 | DECLARATION;		
				 		
DECLARATION  ::= DECL_CHAMP POINT_VIRGULE 
			 | DECL_CONST POINT_VIRGULE;
			 
DECL_CHAMP ::= STATUT:s TYPE:t IDF:idf
			   {: variables.ajouterVariable(idf,deplacement); deplacement += 4; :}
   		   | STATUT:s TYPE:t IDF:idf LIDF 
   			 {: variables.ajouterVariable(idf,deplacement); deplacement += 4;  :};

LIDF ::= VIRGULE IDF:idf LIDF
		 {: variables.ajouterVariable(idf,deplacement); deplacement += 4; :}
	 | VIRGULE IDF:idf
	   {: variables.ajouterVariable(idf,deplacement); deplacement += 4; :};

DECL_CONST ::= INSTRUCTION;

INSTRUCTION ::= AFFECT | LIRE | ECRIRE;

AFFECT ::= IDF:idf EGALE EXP:e
		   {: lexique.ajouterAction(new Affectation(idf,e)) ;:}   
   	   | IDF:idf EGALE PLUS EXP:e
   		 {: lexique.ajouterAction(new Affectation(idf,new Somme(e,e))); :};

LIRE ::= LIR IDF:idf
		 {: lexique.ajouterAction(new LireEntier(idf,j)); j++; :};

ECRIRE ::= ECRIR CSTE_CHAINE:chaine
		   {:  lexique.ajouterAction(new EcrireChaine(chaine,j)); j++;:}
   	   | ECRIR EXP:e 
		 {:  lexique.ajouterAction(new EcrireExpression(e)); :};	

EXP ::= CSTE_ENT:cste
	  	{:RESULT = new Nombre(Integer.parseInt(""+cste)); :}
	| PARENTHESE_OUVERT EXP:e PARENTHESE_FERMER
	  {: RESULT = e; :}
	| MOINS EXP:e
	  {: RESULT = new Multiplication(new Nombre(-1),e); :}
	| EXP:e1 PLUS EXP:e2
	  {: RESULT = new Somme(e1,e2); :}
	| EXP:e1 MOINS EXP:e2
	  {: RESULT = new Difference(e1,e2); :}
	| EXP:e1 FOIS EXP:e2
	  {: RESULT = new Multiplication(e1,e2); :}
	| EXP:e1 INF EXP:e2
	  {: RESULT=new Inferieur(e1,e2,i); i++; :}
	| EXP:e1 SUP EXP:e2
	  {: RESULT=new Superieur(e1,e2,i); i++; :}
	| EXP:e1 TEST_EGAL EXP:e2
	  {: RESULT=new TestEgal(e1,e2,i); i++; :}
	| EXP:e1 TEST_NON_EGAL EXP:e2
	  {: RESULT=new TestNonEgal(e1,e2,i); i++; :}
	| IDF:idf
	  {: RESULT=new Idf(idf); :};
	  
	  
