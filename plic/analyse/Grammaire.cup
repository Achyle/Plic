package plic.analyse;

import plic.arbre.ArbreAbstrait;
import plic.arbre.expression.Different;
import plic.arbre.expression.Egale;
import plic.arbre.expression.Expression;
import plic.arbre.expression.Inferieur;
import plic.arbre.expression.Multiplication;
import plic.arbre.expression.Somme;
import plic.arbre.expression.Soustraction;
import plic.arbre.expression.Superieur;
import plic.arbre.expression.Unaire;

action code {: 
			:}; 

parser code {:

    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));   
                if (s.right >= 0)                    
                    m.append(", column "+(s.right+1));
            }
        }

        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

terminal String CSTE_ENT, PARENTHESE_OUVERT, PARENTHESE_FERMER, PLUS, MOINS, FOIS, INF, SUP, EGALE, DIFFERENT, BOOL;

non terminal ArbreAbstrait SYSTEME;
non terminal ArbreAbstrait LEXP;
non terminal Expression EXP;

precedence left BOOL;
precedence left INF, SUP, EGALE, DIFFERENT;
precedence left PLUS, MOINS;
precedence left FOIS;

start with SYSTEME;

SYSTEME	::= LEXP:lx
	{: RESULT = lx; :};

LEXP ::= EXP:e
	   {: ArbreAbstrait arbre = new ArbreAbstrait();
	      arbre.ajouterAction(e);
	      RESULT = arbre; :};

EXP ::= CSTE_ENT:cste
	  	{: RESULT = new Unaire(Integer.parseInt(""+cste),false); :}
	| PARENTHESE_OUVERT EXP:e PARENTHESE_FERMER
	  {: RESULT = e; :}
	| MOINS EXP:e
	  {: RESULT = new Multiplication(new Unaire(-1,false),e); :}
	| EXP:e1 PLUS EXP:e2
	  {: RESULT = new Somme(e1,e2); :}
	| EXP:e1 MOINS EXP:e2
	  {: RESULT = new Soustraction(e1,e2); :}
	| EXP:e1 FOIS EXP:e2
	  {: RESULT = new Multiplication(e1,e2); :}
	| EXP:e1 INF EXP:e2
	  {: RESULT=new Inferieur(e1,e2); :}
	| EXP:e1 SUP EXP:e2
	  {: RESULT=new Superieur(e1,e2); :}
	| EXP:e1 EGALE EXP:e2
	  {: RESULT=new Egale(e1,e2); :}
	| EXP:e1 DIFFERENT EXP:e2
	  {: RESULT=new Different(e1,e2); :}
	| BOOL:b
	  {: RESULT=new Unaire(b=="vrai"?1:0,true); :};
