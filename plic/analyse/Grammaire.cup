package plic.analyse;

import plic.arbre.Affectation;
import plic.arbre.ArbreAbstrait;
import plic.arbre.Classe;
import plic.arbre.Declaration;
import plic.arbre.DeclarationChamps;
import plic.arbre.DeclarationConstantes;
import plic.arbre.EcrireChaine;
import plic.arbre.EcrireExpression;
import plic.arbre.Lire;
import plic.arbre.ListeDeclaration;
import plic.arbre.ListeIdentifiant;
import plic.arbre.expression.Different;
import plic.arbre.expression.Division;
import plic.arbre.expression.Egale;
import plic.arbre.expression.Expression;
import plic.arbre.expression.Inferieur;
import plic.arbre.expression.Multiplication;
import plic.arbre.expression.Somme;
import plic.arbre.expression.Soustraction;
import plic.arbre.expression.Superieur;
import plic.arbre.expression.Unaire;
import plic.Plic;
import java_cup.runtime.Symbol;

action code {: 
			:}; 

parser code {:

	public void syntax_error(Symbol cur_token){
		
	}

    public void report_error(String message, Object info) {
        
    }

    public void report_fatal_error(String message, Object info) {
    	String mess = "";
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                mess = "ERREUR SYNTAXIQUE : ligne "+(s.left+1);
            }
        }
		System.out.println(mess);
        System.exit(1);
    }
:};

terminal String cste_ent, cste_chaine, parenthese_ouvert, parenthese_fermer, plus, moins, fois, diviser, inf, sup, test_egale;
terminal String test_different, bool, classe, fin, pointvirgule, idf, statut, type, virgule, ecrire, lire, egale;

non terminal ArbreAbstrait SYSTEME;
non terminal Classe CLASSE;
non terminal ListeDeclaration LDECL;
non terminal Declaration DECLARATION;
non terminal DeclarationChamps DECL_CHAMP;
non terminal DeclarationConstantes DECL_CONST;
non terminal ListeIdentifiant LIDF;
non terminal Affectation AFFECT;
non terminal Expression EXP;
non terminal Lire INSTLIRE;
non terminal DeclarationConstantes INSTECRIRE;

precedence left bool;
precedence left inf, sup, test_egale, test_different;
precedence left plus, moins;
precedence left fois, diviser;

start with SYSTEME;

SYSTEME	::= CLASSE:c
	{: 
		Plic.derniereGrammaire = "SYSTEME";
		RESULT = new ArbreAbstrait(c); 
	:};
	
CLASSE ::= classe idf:i LDECL:l fin
	{: 
		Plic.derniereGrammaire = "CLASSE";
		RESULT = new Classe(l,i); 
	:}
	| classe idf:i fin
	{: 
		Plic.derniereGrammaire = "CLASSE VIDE";
		RESULT = new Classe(null,i); 
	:};

LDECL ::= LDECL:l DECLARATION:d
	{: 	
		Plic.derniereGrammaire = "LDECL ADD";
		l.ajouterDeclaration(d);
		RESULT = l; 
	:}
	| DECLARATION:d
	{: 	
		Plic.derniereGrammaire = "LDECL NEW";
		ListeDeclaration l = new ListeDeclaration(); 
		l.ajouterDeclaration(d);
		RESULT = l; 
	:};
	
DECLARATION ::= DECL_CHAMP:d pointvirgule
	{: 
		Plic.derniereGrammaire = "DECLARATION CHAMP";
		RESULT = d; 
	:}
	| DECL_CONST:d pointvirgule
	{: 
		Plic.derniereGrammaire = "DECLARATION CONST";
		RESULT = d; 
	:}
	| DECL_CHAMP:d error
	{:
		System.out.println("On a catcher qui manquer un pointvirgule");
	:};
	
DECL_CHAMP ::= statut:s type:t LIDF:l 
	{: 
		Plic.derniereGrammaire = "DECL_CHAMP";
		RESULT = new DeclarationChamps(s,t,l); 
	:};

LIDF ::= LIDF:l virgule idf:i
	{: 	
		Plic.derniereGrammaire = "LIDF ADD";
		l.ajouterIdentifiant(i);
		RESULT = l; 
	:}
	| idf:i
	{: 	
		Plic.derniereGrammaire = "LIDF NEW";
		ListeIdentifiant l = new ListeIdentifiant();
		l.ajouterIdentifiant(i);
		RESULT = l; 
	:};
	
DECL_CONST ::= AFFECT:a
	{: 
		Plic.derniereGrammaire = "DECL_CONST AFFECT";
		RESULT = a; 
	:}
	| INSTLIRE:i
	{: 
		Plic.derniereGrammaire = "DECL_CONST INSTLIRE";
		RESULT = i; 
	:}
	| INSTECRIRE:i
	{: 
		Plic.derniereGrammaire = "DECL_CONST INSTECRIRE";
		RESULT = i; 
	:};
	
AFFECT ::=  idf:i egale EXP:e 
	{: 
		Plic.derniereGrammaire = "AFFECT EXP";
		RESULT = new Affectation(i,e); 
	:};
	
INSTLIRE ::= lire idf:i
	{: 
		Plic.derniereGrammaire = "INSTLIRE";
		RESULT = new Lire(i); 
	:};

INSTECRIRE ::= ecrire EXP:e
	{: 
		Plic.derniereGrammaire = "INSTECRIRE EXP";
		RESULT = new EcrireExpression(e); 
	:}
	| ecrire cste_chaine:c
	{:
		System.out.println(c);
		Plic.derniereGrammaire = "INSTECRIRE CONSTCHAINE";
		RESULT = new EcrireChaine(c); 
	:};

EXP ::= cste_ent:cste
	{: 
		Plic.derniereGrammaire = "EXP CONST ENT";
		RESULT = new Unaire(Integer.parseInt(""+cste),false); 
	:}
	| parenthese_ouvert EXP:e parenthese_fermer
	{: 
		Plic.derniereGrammaire = "(EXP)";
		RESULT = e; 
	:}
	| moins EXP:e
	{: 
		Plic.derniereGrammaire = "-EXP";
		RESULT = new Multiplication(new Unaire(-1,false),e); 
	:}
	| EXP:e1 plus EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP + EXP";
	  	RESULT = new Somme(e1,e2); 
	:}
	| EXP:e1 moins EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP - EXP";
		RESULT = new Soustraction(e1,e2); 
	:}
	| EXP:e1 fois EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP * EXP";
		RESULT = new Multiplication(e1,e2); 
	:}
	| EXP:e1 diviser EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP / EXP";
		RESULT = new Division(e1,e2); 
	:}
	| EXP:e1 inf EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP < EXP";
		RESULT=new Inferieur(e1,e2); 
	:}
	| EXP:e1 sup EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP > EXP";
		RESULT=new Superieur(e1,e2); 
	:}
	| EXP:e1 test_egale EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP == EXP";
		RESULT=new Egale(e1,e2); 
	:}
	| EXP:e1 test_different EXP:e2
	{: 
		Plic.derniereGrammaire = "EXP != EXP";
		RESULT=new Different(e1,e2); 
	:}
	| bool:b
	{: 
		Plic.derniereGrammaire = "EXP BOOL";
		RESULT = new Unaire(b=="vrai"?1:0,true); 
	:}
	| idf:i
	{:
		Plic.derniereGrammaire = "EXP IDF";
		RESULT = new Unaire(i);	
	:};
